<!--For Extension info, read How to make extensions.txt in Extension folder-->
<!--Transmitter V4.00-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="title" content="LioranBoard Transmitter">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="LioranBoard component which allows Receiver to connect to Twitch and its extensions.">
<meta name="keywords" content="LioranBoard, Transmitter, Twitch, Stream">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="language" content="English">
<title>LioranBoard Transmitter</title>
<link rel="shortcut icon" type="image/x-icon" href="https://christinna9031.github.io/LioranBoard-Transmitter/favicon.ico"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/christinna9031/LioranBoard-Files@main/lib/bootstrap.min.css">
<link href='https://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>
<style>
body {
  font-family: 'Lato', sans-serif;
}
h1 {
font-size: calc(1.2em + 1vw);
}
a {
  color: #ffac7c;
  text-decoration: underline;
}
a:hover {
  color: #ff6810;
  text-decoration: underline;
}
.tslCollapse, .tslCollapse:hover, .tslCollapse a {
  text-decoration: none;
  color: #FFFFFF;
}
.tslCollapse.collapsed:before {
  content:'Show Options \01F847' ;
  width:15px;
}
.tslCollapse:before {
  content:'Hide Options \01F845' ;
  width:15px;
}
#footer .tslCollapse.collapsed:before {
  content:'Show Installed Extensions \01F847' ;
  width:15px;
}
#footer .tslCollapse:before {
  content:'Hide Installed Extensions \01F845' ;
  width:15px;
}

#LBreceiverlog, #LBchatlog, #LBpubsublog {
  background:rgb(10, 11, 26);
  padding:5px 15px;
  display:block;
  position: relative;
  float: left;
  text-align: left;
  max-height: 50%;
  overflow-y: auto;
}

#debugLogContent, #debugLog {
  border:none;
  background-color:rgba(0,0,0,0);
  box-shadow:none;
}
#debugLog .nav-link {
  padding: .2rem 1rem;
}
#LBChat, #LBPubSub, #LBreceiver {
  overflow: hidden;
  padding:5px;
  margin:2px;
  padding: 1px 
}
samp {
  width: 200px;
  word-break: break-all;
  white-space: normal;
}

input{
 padding:0px;
 margin:1px 1px
}
button{
 padding:2px 5px;
 margin:3px 0;
 box-shadow:2 2px #c5c5c5
}
button:active{
 background-color:#797979;
 color:#fff;
 box-shadow:0 0 rgb(223, 223, 223);
 transform:translateY(1px)
}
.nav {
  padding-left: 0;
  margin-bottom: 0;
}

.nav-pills .nav-link {
  font-family: Arial;
  padding: .4em .6em .1em .6em;
  margin: 2px 1px 0px 1px!important;
  background: rgb(175,177,184);
  background-color: linear-gradient(0deg, rgba(175,177,184,1) 15%, rgba(203,203,213,1) 61%);
  font-weight: bold;
  color:rgb(31, 32, 54);
  border-radius: 5px 5px 0px 0px;
  text-shadow: 0px 1px 2px rgb(195, 195, 195);
  transition: 0.01s;
}

.nav-pills > li > .nav-link.active {
   background-image: linear-gradient(to bottom, #E28B3B, #B96C23);
   color: rgb(255, 255, 255);
   border: 1px solid #8F8C8C;
   text-shadow: 1px 1px 3px rgb(0 0 0 / 100%);
 }
 
 .tab-content {
   background-color: rgba(39, 55, 110, 0.5);
   box-shadow: 0.5rem 0.5rem 0.5rem #00000080;
   min-height:50px;
   width:100%;
   border-radius:3px;
   overflow:hidden;
   padding:20px;
 }
 .draggable-source--is-dragging {
   opacity: 0;
 }

#versionOBS:after {
 content:'OBS Studio'
}
#versionOBSWS:after {
 content:'OBS Websocket'
}
#versionReceiver:after {
 content:'LB Receiver'
}
#versionStreamDeck:after {
 content:'LB StreamDeck (PC)'
}
#versionTransmitter:after {
 content:'LB Transmitter'
}
@media (max-width: 576px) {
  .nav-pills .nav-link {
      border-radius: 5px 5px 0px 0px;
      font-weight:bold;
      padding: .2em .4em .1em .4em;
      font-size: 0.92em 
 }
  button{
     font-size:0.93em;
      padding:2px 5px;
     margin:3px 0;
     box-shadow:2 2px #c5c5c5
 }
 button:active{
     background-color:#797979;
     color:#fff;
     box-shadow:0 0 rgb(223, 223, 223);
     transform:translateY(1px)
 }
  #versionOBS:after {
     content:'OBS'
 }
  #versionOBSWS:after {
     content:'OBSWS'
 }
  #versionReceiver:after {
     content:'LBR'
 }
  #versionStreamDeck:after {
     content:'LBS PC'
 }
  #versionTransmitter:after {
     content:'LBT'
 }
}


.notabs>.tab-pane {
  display: block !important;
  opacity: 1 !important;
}
.notabs button, .notabs input{
 color:#fff;
 background-color:#4c4c4c;
 border-color:#464546
}
.connected{
 color:#4ad84a
}
.disconnected{
 color:#fb4848
}

</style>
</head>
<body>
<div class="container">
<h1 class="text-center">LioranBoard Transmitter </h1>
<!-- Connection Info -->
<div class="row justify-content-center">
  <div class="col col-auto">
    <svg id="toclient_circle" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="red" class="bi bi-circle-fill d-md-none me-1" viewBox="0 0 16 16">
        <circle cx="8" cy="8" r="8"/>
      </svg>
    <span>Receiver</span><span class="d-none d-md-inline-flex me-1">: </span><span id="toclient" class="disconnected d-none d-md-inline-flex">Not connected.</span>
  </div>
  <div class="col col-auto">
    <svg id="topubsub_circle" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="red" class="bi bi-circle-fill d-md-none me-1" viewBox="0 0 16 16">
        <circle cx="8" cy="8" r="8"/>
      </svg>
    <span>Pubsub</span><span class="d-none d-md-inline-flex me-1">: </span><span class="disconnected d-none d-md-inline-flex" id="topubsub">Not connected.</span>
  </div>
  <div class="col col-auto">
    <svg id="tochat_circle" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="red" class="bi bi-circle-fill d-md-none me-1" viewBox="0 0 16 16">
        <circle cx="8" cy="8" r="8"/>
      </svg>
    <span>Chat</span><span class="d-none d-md-inline-flex me-1">: </span><span class="disconnected d-none d-md-inline-flex" id="tochat">Not connected.</span>
  </div>
</div> <br>
<!--Tabs -->
<div class="row justify-content-center g-0">
    <ul class="nav nav-pills mb-0" id="extensions-tab" role="tablist">
</div>  
 <!-- Tab Content -->
 <div class="tab-content" id="extensions-tabContent">
<!--Twitch Triggers external-->
<div class="tab-pane" id="content-basic" role="tabpanel" title="Twitch Triggers" data-type="default">
    <button type="button" onclick="fakesub2()">Test Sub</button>
    <a class="tslCollapse collapsed" data-bs-toggle="collapse" href="#hidesubs" role="button" aria-expanded="false" aria-controls="hidesubs"></a>  
    <div class="collapse" id="hidesubs"> 
       <input type="radio" id="itier1" name="tier" value="vtier1" checked>
       Tier 1
       <input type="radio" id="itier2" name="tier" value="vtier2">
       Tier 2
       <input type="radio" id="itier3" name="tier" value="vtier3" >
       Tier 3
       <input type="radio" id="iprime" name="tier" value="vprime" onclick="CheckUncheckSubGift(this)" >
       Prime <br>
       <input type="checkbox" id="isubgift" name="subgift" value="vsubgift" onclick="CheckUncheckSubGift(this)">
       SubGift
       <input type="checkbox" id="ianongift" name="subgift" value="vanongift" onclick="CheckUncheckSubGift(this)">
       AnonGift 
       <input type="number" min="0" max="100" id="nsubmonths" name="nsubmonths" value=1> Months <br>
       Message:	
       <input type="text" id="nsubmessage" name="nsubmessage" size="20" value='Hello World!'>
    </div>
    <div>
       <button type="button" onclick="fakegiftamount()">Test Subs Gift Amount</button>
       Amount:
       <input type="number" min="0" max="999" id="igiftamount" name="ngiftamount" value=1> 
    </div>
    <button type="button" onclick="fakebits()">Test Bits</button>
    <a class="tslCollapse collapsed" data-bs-toggle="collapse" href="#hidebits" role="button" aria-expanded="false" aria-controls="hidebits"></a>
    <div class='collapse' id="hidebits"> 
       Amount of bits:
       <input type="number" min="0" max="999" id="ibitsamount" name="nbitsamount"  value=1>
       Total bits: 	
       <input type="number" min="0" max="999" id="ibitstotal" name="ibitstotal" value=1000><br/>
       Message:	
       <input type="text" id="ibitsmessage" name="ibitsmessage" size="20" style="margin:5px 0px;" value='Hello World!'>
    </div>
    <div><button type="button" onclick="fakepoints()">Test Channel Points</button> 
       <a class="tslCollapse collapsed" data-bs-toggle="collapse" href="#hidepoints" role="button" aria-expanded="false" aria-controls="hidebits"></a>
    </div>
    <div class="collapse" id="hidepoints" >
      Redeem Name:
      <input type="text" id="ichannelpoints" name="nchannelpoints" size="10" style="margin:5px 0px">	<input type="checkbox" id="nchannelpointinput" name="nchannelpointinput" > User Input Required <br>
      Redeem Message:	
      <input type="text" id="nchannelpointsmsg" name="nchannelpointsmsg" size="20"  >	<br>
      Redeem Cost:	
      <input type="text" id="nchannelpointscost" name="nchannelpointscost" size="5"  >	
   </div>
    <div><button type="button" onclick="fakeraid()">Test Raid</button>
       Amount:
       <input type="number" min="0" max="999" id="iraidamount" name="nraidamount"  value=1> 
    </div>
    <div><button type="button" onclick="fakehost()">Test Host</button>
       Amount:
       <input type="number" min="0" max="999" id="ihostamount" name="nhostamount"  value=1>
    </div>
    <div><button type="button" onclick="fakechatmsg()">Test Chat Message </button> 	
       <a class="tslCollapse collapsed" data-bs-toggle="collapse" href="#hidechatmsg" role="button" aria-expanded="false" aria-controls="hidechatmsg"></a>
    </div>
    <div class="collapse" id="hidechatmsg">
       Username: <input type="text" id="ichatname" size="10" value="Lioran"> <br> Message: <input type="text" id="ichatmsg" size="20" style="margin:5px 0px"; value="Hello World">	<br>
       <input type="checkbox" id="ichatbroadcaster"> Broadcaster <input type="checkbox" id="ichatmod"> Mod <input type="checkbox" id="ichatsub"> Subscriber <input type="checkbox" id="ichatvip"> VIP <br>
       Subscriber Tier: 
       <select id="chatmsgsubtier">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
       </select>
       Month:  <input type="number" min=0 max=12 maxlength="2" oninput="javascript: if (parseInt(this.value) > parseInt(this.max)) this.value = this.max;" id="chatmsgsubmonth" value=1>
    </div>
  </div>
  <!--Twitch Triggers external end-->
<div class="tab-pane" id="content-status" role="tabpanel" title="Status" data-type="default">
<!--Get Version external-->
<div class='row ml-5 pl-5'>
    <style>
       #version_output a{
       color: #fb4848;
       }
       #version_output td{
       padding:0px 10px;
       }
    </style>
    <h5>Version</h5>
    <table  class="table ms-2 table-responsive table-Dark table-striped w-auto align-middle" id='version_output'>
       <thead>
          <tr>
             <th scope="col">Name</th>
             <th scope="col">Latest</th>
             <th scope="col">Current</th>
             <th scope="col">Status</th>
          </tr>
       </thead>
       <tbody>
          <tr>
             <th scope="row" id='versionOBS'></th>
             <td id='obs_latestV'></td>
             <td id='obs_currentV'></td>
             <td id='obs_status'></td>
          </tr>
          <tr>
             <th scope="row" id='versionOBSWS'></th>
             <td id='obsws_latestV'></td>
             <td id='obsws_currentV'></td>
             <td id='obsws_status'></td>
          </tr>
          <tr>
             <th scope="row" id='versionReceiver'></th>
             <td id='receiver_latestV'></td>
             <td id='receiver_currentV'></td>
             <td id='receiver_status'></td>
          </tr>
          <tr>
             <th scope="row" id='versionStreamDeck'></th>
             <td id='streamdeck_latestV'></td>
             <td id='streamdeck_currentV'></td>
             <td id='streamdeck_status'></td>
          </tr>
          <tr>
             <th scope="row" id='versionTransmitter'></th>
             <td id='transmitter_latestV'></td>
             <td id='transmitter_currentV'></td>
             <td id='transmitter_status'></td>
          </tr>
       </tbody>
    </table>
 </div>
 <div class='row pt-2'> <span><button onclick='LBGetVersion()'>Refresh</button> </span> </div>
<!--Get Version external end-->
  <div class='row pt-3'>
     <h5>Appearance</h5>
     <div class="col col-md-auto"><button type="button" onclick="TSLNoTabs()">No Tabs</button><button type="button" onclick="TSLTabs()">Show Tabs</button></div>
  </div>
<!--Message Logging external-->
<div class='row pt-3 d-block'>
    <h5>Message Logging</h5>
    <div class='pl-5 ml-5'>
       <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="dbgReceiver" onclick="LBDebugLog(this)" >
          <label class="form-check-label"for="flexSwitchCheckDefault">Receiver</label>
       </div>
       <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="dbgPubsub" onclick="LBDebugLog(this)">
          <label class="form-check-label" for="flexSwitchCheckDefault">PubSub</label>
       </div>
       <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="dbgChat" onclick="LBDebugLog(this)">
          <label class="form-check-label" for="flexSwitchCheckDefault">Twitch Chat</label>
       </div>
       <ul class="nav nav-tabs mt-3" id="debugLog" role="tablist">
          <li class="nav-item" role="presentation">
             <button class="nav-link active" id="LBreceiver-tab" data-bs-toggle="tab" data-bs-target="#LBreceiver" type="button" role="tab" aria-controls="LBreceiver" aria-selected="true">Receiver</button>
          </li>
          <li class="nav-item" role="presentation">
             <button class="nav-link" id="LBPubSub-tab" data-bs-toggle="tab" data-bs-target="#LBPubSub" type="button" role="tab" aria-controls="LBPubSub" aria-selected="false">PubSub</button>
          </li>
          <li class="nav-item" role="presentation">
             <button class="nav-link" id="LBChat-tab" data-bs-toggle="tab" data-bs-target="#LBChat" type="button" role="tab" aria-controls="LBChat" aria-selected="false">Chat</button>
          </li>
       </ul>
       <div class="tab-content p-0 " id="debugLogContent">
          <!--LB Receiver Log-->
          <div class="tab-pane fade show active" id="LBreceiver" role="tabpanel" aria-labelledby="LBreceiver-tab" >
             <div id="LBreceiverlog" class="col col-10 text-wrap">Logging is disabled.</div>
          </div>
          <!--LB Pubsub Log-->
          <div class="tab-pane fade" id="LBPubSub" role="tabpanel" aria-labelledby="LBPubSub-tab">
             <div id="LBpubsublog" class="col col-10 text-wrap">Logging is disabled.</div>
          </div>
          <!--LB Chat Log-->
          <div class="tab-pane fade" id="LBChat" role="tabpanel" aria-labelledby="LBChat-tab">
             <div id="LBchatlog" class="col col-10 text-wrap">Logging is disabled.</div>
          </div>
       </div>
    </div>
 </div>
<!--Message Logging external end-->
</div>
<!--Follower Alert external-->
<div id="content-Follower_Alert" class="tab-pane" title="Follower Alert" data-type="default">
    <div>Follower Alert extension is installed.</div>
    <button type="button" onclick="fakefollow()">Test Follower Trigger</button>
  </div>
<!--Follower Alert external end-->
<!--Change Stream external-->
<div class="tab-pane" id="content-Change_Twitch_Status" role="tabpanel" title="Change Twitch Status" data-type="default">
    <div>
       <p>Change Stream extension is installed</p>
    </div>
  </div>
<!--Change Stream external end-->
<!--Viewer Count external-->
<div class="tab-pane" id="content-Viewer_Count" role="tabpanel" title="Viewer Count" data-type="default">
    <div>
       <p>Get Viewer Count extension is installed</p>
    </div>
  </div>
<!--Viewer Count external end-->
<!--Subscriber Count external-->
<div id="content-Subscriber_Count" class="tab-pane" title="Subscriber Count" data-type="default">
    <div>
       <p>Get Subscriber Count extension is installed</p>
    </div>
  </div>
<!--Subscriber Count external end-->
<!--Get Channel ID external-->
<div id="content-Get_Channel_ID" class="tab-pane" title="Get Channel ID" data-type="default">
    <div>
       <p>Get Channel ID extension is installed</p>
    </div>
  </div>
<!--Get Channel ID external end-->
<!--Bits Leaderboard external-->
<div id="content-Bits_Leaderboard" class="tab-pane" title="Bits Leaderboard" data-type="default">
    <div>
       <p>Bits Leaderboard extension is installed.</p>
    </div>
  </div>
<!--Bits Leaderboard external end-->
<!--Get Profile Picture external-->
<div id="content-Get_Profile_Picture" class="tab-pane" title="Get Profile Picture" data-type="default">
    <div>
       <p>Get user profile picture extension is installed.</p>
    </div>
  </div>
<!--Get Profile Picture external end-->
<!--Your external script will be inserted here-->
<!--<script src="example.js"></script>-->
<!--INSERT PART 1-->
 
</div>
<div class="row justify-content-center mt-3 px-2 mb-5" id="footer"> <a class="tslCollapse collapsed" data-bs-toggle="collapse" href="#installedextensions" role="button" aria-expanded="false" aria-controls="installedextensions"></a>
  <span class='collapse' id="installedextensions"></span>
  <span id ='extensions-tab-buttons' class="mt-2">
  <button id="extensionsshow">Show All Tabs</button> <button id="extensionshide">Hide All Tabs</button> <button id="extensionsresetorder">Reset Tab Order</button> <button onclick="location.reload()">Refresh</button></span>
</div>


</div>
</body>
<script>
  // url for lioranboard
  let url = 'ws://127.0.0.1:9423';
  // if you make an extension and it connects to twitch, use this id
  const TWITCH_CLIENT_ID = 'tpqy40pm79e00s63cqusqepvhwqz1n';
  // value that says if pubsub is connected or not
  let on_server = 0;
  let i_force = '';
  let twitchreconnecting = 0;
  let twitchpingid = 0;
  let just_raided = [];
  LBDebugPost = (typeof LBDebugPost !== 'undefined') ? LBDebugPost : null

// modify UI on load
window.addEventListener('load', LBLoadTabsUI, false);
function LBLoadTabsUI() {
  const tabList = {};
  let tabSortList = JSON.parse(localStorage.getItem('tabsSortList')) || [];
  const newtabSortList = [];
  const tabsVisibility = JSON.parse(localStorage.getItem('tabsVisibility')) || [];
  let lastActiveTab = localStorage.getItem('tabsActive') || 'content-basic';
  lastActiveTab = (document.getElementById(lastActiveTab)) ? lastActiveTab : 'content-basic'
  const installedExt = document.querySelector('#installedextensions');
  const ul = document.getElementById('extensions-tab');
  const parent = document.getElementById('extensions-tabContent');
  const contentLi = parent.querySelectorAll('.tab-pane');
  const contentAll = [].slice.call(contentLi).filter((n) => n.parentNode.closest('.tab-pane') === parent.closest('.tab-pane'));
  const defaultContent = contentAll.filter((e) => e.dataset.type === 'default');
  const addedContent = contentAll.filter((e) => e.dataset.type !== 'default');
  const content = defaultContent.concat(addedContent.reverse());
  const activeTab = document.getElementById(lastActiveTab);
  activeTab.className = 'tab-pane active';

  // create tabs and checkboxes
  content.forEach((e) => {
    createExtensionTab(e);
    createExtensionBox(e);
  });
  SortTabs();

  tabSortList = newtabSortList;
  localStorage.setItem('tabsSortList', JSON.stringify(newtabSortList));

  // add drag and sort functionality to tabs
  const draggable = new Draggable.Sortable(ul, {
    draggable: 'li',
    distance: 1,
    sortAnimation: {
      duration: 200,
      easingFunction: 'ease-in-out',
    },
    plugins: [Draggable.Plugins.SortAnimation],
  });

  // save a new sort order
  draggable.on('sortable:sorted', (e) => {
    const sortArr = JSON.parse(localStorage.getItem('tabsSortList'));
    sortArr.splice(e.newIndex, 0, sortArr.splice(e.oldIndex, 1)[0]);
    localStorage.setItem('tabsSortList', JSON.stringify(sortArr));
  });

  // change and save tab visibility
  document.querySelector('#installedextensions').onclick = (ev) => {
    if (ev.target.value) {
      const id = ev.target.id.slice(8);
      const li = document.querySelector(`[aria-controls="${id}"]`);

      if (ev.target.checked) {
        li.classList.remove('d-none');
      } else {
        li.classList.add('d-none');
      }
      SaveExttabsVisibility();
    }
  };

  // show all tabs
  document.querySelector('#extensionsshow').onclick = () => {
    localStorage.removeItem('tabsVisibility');
    location.reload();
  };

  // hide all tabs
  document.querySelector('#extensionshide').onclick = () => {
    const tabsVisiblity = {};
    document.querySelectorAll('#installedextensions input[type=checkbox]').forEach((e) => {
      const id = e.id.slice(8);
      tabsVisiblity[id] = false;
    });
    localStorage.setItem('tabsVisibility', JSON.stringify(tabsVisiblity));
    window.location.reload();
  };

  // reset tab order
  document.querySelector('#extensionsresetorder').onclick = () => {
    localStorage.removeItem('tabsSortList');
    window.location.reload();
  };

  // save active tab
  ul.querySelectorAll('button').forEach((btn) => btn.onclick = (btn) => {
    localStorage.setItem('tabsActive',btn.target.id.slice(0,-4))
  });

  // create all tabs
  function createExtensionTab(e) {
    const { title } = e;
    const { id } = e;
    const li = document.createElement('li');
    const button = document.createElement('button');
    const hide = (typeof tabsVisibility[id] !== 'undefined' && tabsVisibility[id] === false) ? 'd-none' : '';
    const active = (lastActiveTab === id) ? 'active' : '';
    li.setAttributes({ class: 'nav-item', role: 'presentation', draggable: 'true' });
    button.setAttributes({
      class: `nav-link draggable-source ${active} ${hide}`, id: `${id}-tab`, 'data-bs-toggle': 'pill', 'data-bs-target': `#${id}`, type: 'button', role: 'tab', 'aria-controls': id, 'aria-selected': 'false', draggable: 'true',
    });
    button.innerHTML = title;
    li.appendChild(button);
    tabList[id] = li;
  }

  // create all tab check boxes
  function createExtensionBox(e) {
    const checkbox = document.createElement('input');
    const text = document.createElement('span');
    text.innerHTML = `${e.title}  `;
    checkbox.type = 'checkbox';
    checkbox.id = `checkbox${e.id}`;
    checkbox.checked = !((typeof tabsVisibility[e.id] !== 'undefined' && tabsVisibility[e.id] === false));
    text.prepend(checkbox);
    installedExt.appendChild(text);
  }

  // sort tabs
  function SortTabs() {
    let i = 0;
    do {
      const childId = tabSortList[i] || Object.keys(tabList)[0];
      try {
        ul.appendChild(tabList[childId]);
        newtabSortList.push(childId);
      } catch (e) { console.log(e); }
      delete tabList[childId];
      i += 1;
    } while (Object.keys(tabList).length > 0);
  }

  // save tabs visiblity
  function SaveExttabsVisibility() {
    const tabsVisiblity = JSON.parse(localStorage.getItem('tabsVisibility')) || {};
    document.querySelectorAll('#installedextensions input[type=checkbox]').forEach((e) => {
      const id = e.id.slice(8);
      tabsVisiblity[id] = e.checked;
    });
    localStorage.setItem('tabsVisibility', JSON.stringify(tabsVisiblity));
  }
};

// switch to no tabs UI
function TSLNoTabs() {
  document.getElementById('extensions-tab').className = 'd-none d-flex';
  document.getElementById('extensions-tabContent').className = 'notabs';
  document.getElementById('extensions-tab-buttons').className = 'd-none mt-2';
}

// switch to tabs UI
function TSLTabs() {
  document.getElementById('extensions-tab').className = 'nav nav-pills mb-3';
  document.getElementById('extensions-tabContent').className = 'tab-content';
  document.getElementById('extensions-tab-buttons').className = 'mt-2';
}

// change connection status UI
function ConnectionStatus(id, status, text, fill) {
  document.getElementById(id).className = `${status} d-none d-md-inline-flex`;
  document.getElementById(id).innerHTML = ` ${text}`;
  document.getElementById(`${id}_circle`).setAttribute('fill', fill);
}

// helper function to set multiple element attributes at once
Element.prototype.setAttributes = function (obj) {
  for (const prop in obj) {
    this.setAttribute(prop, obj[prop]);
  }
};

// fake subscriber testing
function fakesub() {
  let i_str;
  let i_name = fakename();
  if (i_force != '') { i_name = i_force; }
  const i_name2 = fakename(i_name);
  const i_value = (itier2.checked) ? 2000 : (itier3.checked) ? 3000 : (iprime.checked) ? 'Prime' : 1000;
  const i_context = (isubgift.checked) ? 'subgift' : (ianongift.checked) ? 'anonsubgift' : 'resub';
  const messages = ['Hello world!', "Love your stream, you are a very genuine guy and you're not affraid to say it how it is. But, I would just prefer if you didn't give your opinion, just saying.", 'Supporting how I can, keep up the great work.', 'All that glitters is not gold. Fair is foul, and foul is fair Hover through the fog and filthy air. These violent delights have violent ends. Hell is empty and all the devils are here. By the pricking of my thumbs, Something wicked this way comes. Open, locks, Whoever knocks!'];
  const i_message = nsubmessage.value || messages[Math.floor(Math.random() * messages.length)];
  const months = nsubmonths.value || Math.ceil(Math.random() * 10);
  const context = (months > 1) ? 'resub' : 'sub';
  if (i_context === 'resub') { i_str = `{"type": "MESSAGE","data": {"topic": "channel-subscribe-events-v1.44322889","message": "{\\"user_name\\": \\"${i_name.toLowerCase()}\\",\\"display_name\\": \\"${i_name}\\",\\"channel_name\\": \\"twitch\\",\\"user_id\\": \\"44322889\\",\\"channel_id\\": \\"12826\\",\\"time\\": \\"2015-12-19T16:39:57-08:00\\",\\"sub_plan\\": \\"${i_value}\\",\\"sub_plan_name\\": \\"Channel Subscription (mr_woodchuck)\\",\\"cumulative_months\\": ${months},\\"streak_months\\": 1,\\"context\\": \\"${context}\\",\\"sub_message\\": {\\"message\\": \\"${i_message}\\",\\"emotes\\": [{\\"start\\": 23,\\"end\\": 7,\\"id\\": 2867}]}}"}}`; }
  if (i_context === 'subgift') { i_str = `{"type": "MESSAGE","data": {"topic": "channel-subscribe-events-v1.44322889","message": "{\\"user_name\\": \\"${i_name.toLowerCase()}\\",\\"display_name\\": \\"${i_name}\\",\\"channel_name\\": \\"twitch\\",\\"user_id\\": \\"44322889\\",\\"channel_id\\": \\"12826\\",\\"time\\": \\"2015-12-19T16:39:57-08:00\\",\\"sub_plan\\": \\"${i_value}\\",\\"sub_plan_name\\": \\"Channel Subscription (mr_woodchuck)\\",\\"months\\": ${months},\\"context\\": \\"subgift\\",\\"sub_message\\": {\\"message\\": \\"${i_message}\\",\\"emotes\\": null },\\"recipient_id\\": \\"13405587\\",\\"recipient_user_name\\": \\"${i_name2.toLowerCase()}\\",\\"recipient_display_name\\": \\"${i_name2}\\"}}"}}`; }
  if (i_context === 'anonsubgift') { i_str = `{"type": "MESSAGE","data": {"topic": "channel-subscribe-events-v1.44322889","message": "{\\"channel_name\\": \\"twitch\\",\\"channel_id\\": \\"12826\\",\\"time\\": \\"2015-12-19T16:39:57-08:00\\",\\"sub_plan\\": \\"${i_value}\\",\\"sub_plan_name\\": \\"Channel Subscription (mr_woodchuck)\\",\\"months\\": ${months},\\"context\\": \\"anonsubgift\\",\\"sub_message\\": {\\"message\\": \\"${i_message}\\",\\"emotes\\": null },\\"recipient_id\\": \\"13405587\\",\\"recipient_user_name\\": \\"${i_name2.toLowerCase()}\\",\\"recipient_display_name\\": \\"${i_name2}\\"}"}}`; }
  console.log('Fake Test Sub sent.'); lioranboardclient.send(i_str);
}

function fakesub2() {
  if (i_force == '') { fakesub(); }
}

// fake gift sub testing
function fakegiftamount() {
  if (i_force !== '') { return 0; }
  i_force = fakename();
  if (igiftamount.value < 1) { igiftamount.value = 1; }
  if (igiftamount.value > 100) { igiftamount.value = 100; }
  if (iprime.checked == true) { iprime.checked = false; itier1.checked = true; }
  if (ianongift.checked == false) { isubgift.checked = true; } else { i_force = 'Anonymous User'; }
  let i_value = 'Tier 1'; if (itier2.checked == true) { i_value = 'Tier 2'; } if (itier3.checked == true) { i_value = 'Tier 3'; }
  console.log(`Fake sub gift amount of ${igiftamount.value} sent.`); lioranboardclient.send(`{"type":"MESSAGE","topic":"FakeNotification","fake":0,"amount":"${igiftamount.value}","name":"${i_force}","tier":"${i_value}"}`);
  for (let ii = 0; ii < igiftamount.value; ii++) {
    setTimeout(fakesub, 1000 + ii * 10);
  }
  setTimeout(forcenameoff, 2100);
}

// check/uncheck boxes if sub is anon, prime etc.
function CheckUncheckSubGift(e) {
  itier1.checked = ((e.id === 'isubgift' || e.id === 'ianongift') && iprime.checked) ? true : itier1.checked;
  iprime.checked = !((e.id === 'isubgift' || e.id === 'ianongift'));
  ianongift.checked = ((e.id === 'iprime' || e.id === 'isubgift')) ? false : ianongift.checked;
  isubgift.checked = ((e.id === 'iprime' || e.id === 'ianongift')) ? false : isubgift.checked;
}

function forcenameoff() {
  i_force = '';
}

// fake bits testing
function fakebits() {
  const i_name = fakename();
  ibitsamount.value = (ibitsamount.value < 1) ? 1 : ibitsamount.value;
  const message = ibitsmessage.value.replace(/"/g, "'") || 'Enjoy the non-existant bits, Even if, only for a short time you got the dopamine of seeing a bits notification. Have a good day.';
  const total = ibitstotal.value || Math.ceil(Math.random() * 5000);
  i_value = parseFloat(ibitsamount.value); if (isNaN(i_value) == true) i_value = 1; if (i_value <= 0) i_value = 1;
  i_str = `{"type": "MESSAGE","data": {"topic": "channel-bits-events-v2.46024993","message": "{\\"data\\":{\\"user_name\\":\\"${i_name.toLowerCase()}\\",\\"channel_name\\":\\"twitch\\",\\"user_id\\":\\"95546976\\",\\"channel_id\\":\\"46024993\\",\\"time\\":\\"2017-02-09T13:23:58.168Z\\",\\"chat_message\\":\\"${message}\\",\\"bits_used\\":${i_value},\\"total_bits_used\\":${total},\\"context\\":\\"cheer\\",\\"badge_entitlement\\":{\\"new_version\\":25000,\\"previous_version\\":10000}},\\"version\\":\\"1.0\\",\\"message_type\\":\\"bits_event\\",\\"message_id\\":\\"8145728a4-35f0-4cf7-9dc0-f2ef24de1eb6\\",\\"is_anonymous\\":true}"}}`;
  console.log(`Fake Test bits for ${i_value}`); lioranboardclient.send(i_str);
}

// fake channel points testing
function fakepoints() {
  const i_name = fakename();
  const title = ichannelpoints.value || 'Test Redeem';
  const message = nchannelpointsmsg.value.replace(/"/g, "'") || 'Testing Message';
  const cost = nchannelpointscost.value || 100;
  i_str = `{"type":"MESSAGE","data":{"topic":"channel-points-channel-v1.23071698","message":"{\\"type\\":\\"reward-redeemed\\",\\"data\\":{\\"timestamp\\":\\"2020-05-10T02:42:01.699693419Z\\",\\"redemption\\":{\\"id\\":\\"f2418f14-1e2b-41f3-90e5-fcad7ab2c701\\",\\"user\\":{\\"id\\":\\"23071698\\",\\"login\\":\\"${i_name.toLowerCase()}\\",\\"display_name\\":\\"${i_name}\\"},\\"channel_id\\":\\"23071698\\",\\"redeemed_at\\":\\"2020-05-10T02:42:01.674616194Z\\",\\"reward\\":{\\"id\\":\\"46b39721-ce2b-4670-8b2d-b520762a3f1e\\",\\"channel_id\\":\\"23071698\\",\\"title\\":\\"${title}\\",\\"prompt\\":\\"Testing Message\\",\\"cost\\":${cost},\\"is_user_input_required\\":${nchannelpointinput.checked},\\"is_sub_only\\":false,\\"image\\":{\\"url_1x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/23071698/46b39721-ce2b-4670-8b2d-b520762a3f1e/d50acf1d-4a0c-4dd0-8596-e5ca0c386332/custom-1.png\\",\\"url_2x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/23071698/46b39721-ce2b-4670-8b2d-b520762a3f1e/d50acf1d-4a0c-4dd0-8596-e5ca0c386332/custom-2.png\\",\\"url_4x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/23071698/46b39721-ce2b-4670-8b2d-b520762a3f1e/d50acf1d-4a0c-4dd0-8596-e5ca0c386332/custom-4.png\\"},\\"default_image\\":{\\"url_1x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/default-1.png\\",\\"url_2x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/default-2.png\\",\\"url_4x\\":\\"https://static-cdn.jtvnw.net/custom-reward-images/default-4.png\\"},\\"background_color\\":\\"#00C7AC\\",\\"is_enabled\\":true,\\"is_paused\\":false,\\"is_in_stock\\":true,\\"max_per_stream\\":{\\"is_enabled\\":false,\\"max_per_stream\\":100},\\"should_redemptions_skip_request_queue\\":true,\\"template_id\\":null,\\"updated_for_indicator_at\\":\\"2020-02-12T18:00:03.401562134Z\\"},\\"user_input\\":\\"${message}\\",\\"status\\":\\"FULFILLED\\"}}}"}}`;
  console.log(`Fake Test Channel Points Redeem "${ichannelpoints.value}" sent.`); lioranboardclient.send(i_str);
}

// fake raid and host testing
function fakeraid() { if (iraidamount.value < 1) { iraidamount.value = 1; } console.log(`Fake Raid of ${iraidamount.value} sent.`); lioranboardclient.send(`{"type":"MESSAGE","topic":"FakeNotification","fake":1,"amount":"${iraidamount.value}","name":"${fakename()}"}`); }
function fakehost() { if (ihostamount.value < 1) { ihostamount.value = 1; } console.log(`Fake Host of ${ihostamount.value} sent.`); lioranboardclient.send(`{"type":"MESSAGE","topic":"FakeNotification","fake":2,"amount":"${ihostamount.value}","name":"${fakename()}"}`); }

// fake chat message testing
function fakechatmsg() {
  const name = ichatname.value || fakename();
  const msg = ichatmsg.value.replace(/"/g, "'") || 'This is a test message.';
  const badge = [];
  const user_id = '123456789';
  if (ichatbroadcaster.checked) { badge.push('broadcaster/1'); }
  if (ichatmod.checked) { badge.push('moderator/1'); }
  if (ichatvip.checked) { badge.push('vip/1'); }
  if (ichatsub.checked) {
    const tier = parseInt(chatmsgsubtier.value);
    let month = (chatmsgsubmonth.value != 1) ? parseInt(chatmsgsubmonth.value) : 0;
    month = (month > 3 && month < 6) ? month = 3 : (month > 6 && month < 9) ? month = 6 : (month > 9 && month < 12) ? month = 9 : month;
    const subBadge = (tier === 1) ? `subscriber/${month}` : (tier === 2) ? `subscriber/${2000 + month}` : `subscriber/${3000 + month}`;
    badge.push(subBadge);
  }
  const chat_obj = {
    emotes: '304822798:0-9/304682444:11-19',
    login: name.toLowerCase(),
    display_name: name,
    user_id,
    color: '#189A8D',
    badge: badge.join(),
    message: msg,
    channel: name,
    topic: 'chatmessage',
    type: 'MESSAGE',
  };
  lioranboardclient.send(JSON.stringify(chat_obj));
}

// fake names for testing
function fakename(name = 'none') {
  const names = ['Lioran', 'nutella4eva', 'Kottpower', 'Neverwho', 'Deomew', 'Doodybeard', 'Exeldro', 'AuralMoral', 'SuperMetroid', 'Melonax', 'Ptoil', 'LinksDarkHalf', 'Derpiii_', 'CoD360_420', 'Bill', 'Kurocha', 'Lisa', 'DeathByButtonMash', 'Daryl', 'Sebas', 'Ramsreef', 'Kelvin214'];
  const randomName = names[Math.floor(Math.random() * names.length)];
  if (name !== randomName) return randomName;
  return fakename(name);
}  
// Receiver connection
// connect to LB
connecttoboard();
// function to establish connection to LB
function connecttoboard() {
  lioranboardclient = (new WebSocket(url));
  lioranboardclient.binaryType = 'arraybuffer';
  // reconnect on disconnect
  lioranboardclient.onclose = () => {
    ConnectionStatus('toclient', 'disconnected', 'Disconnected, attempting to reconnect.', 'red');
    if (on_server == 1) {
      on_server = 0;
      clearTimeout(twitchreconnecting);
      TwitchChatConnect.close();
      pubsubserver.close();
    }
    connecttoboard();
    if (LBDebugPost) LBDebugPost('receiver', 'Connection Closed');
  };

  lioranboardclient.onerror = (e) => {
    if (LBDebugPost) LBDebugPost('receiver', `Connection Error ${JSON.stringify(e)}`);
  };
  // notice that connection is established
  lioranboardclient.onopen = (event) => {
    ConnectionStatus('toclient', 'connected', 'Connected.', 'green');
    if (typeof LBGetVersion !== 'undefined') LBGetVersion();
    if (LBDebugPost) LBDebugPost('receiver', event);

    //[Get Version command]
//[Get Version command end]
//[Message Logging command]
//[Message Logging command end]
//[Change Stream command]
LBSendExtCommand('Change Stream', { oauth_token: 'string', channel_id: 'real', title: 'string', game: 'string' });
//[Change Stream command end]
//[Viewer Count command]
LBSendExtCommand('Get Viewer Count', { channel_id: 'real', value_name: 'string' });
//[Viewer Count command end]
//[Subscriber Count command]
LBSendExtCommand('Get Subscriber Count', { oauth_token: 'string', channel_id: 'real', value_name: 'string' });
//[Subscriber Count command end]
//[Get Channel ID command]
LBSendExtCommand('Get Channel Id', { oauth_token: 'string', name: 'string', Variable: 'string' });
//[Get Channel ID command end]
//[Follower Alert command]
LBSendExtCommand('Follower Alert', { channel_id: 'real' });
//[Follower Alert command end]
//[Bits Leaderboard command]
LBSendExtCommand('Check Leaderboard', { oauth_token: 'string' });
//[Bits Leaderboard command end]
//[Get Profile Picture command]
LBSendExtCommand('Get Profile Picture', { oauth_token: 'string', user_name: 'string', value_name: 'string' });
//[Get Profile Picture command end]
// You LioranBoard extension command will be inserted here
/*INSERT PART 2*/
 

  };
  // receiving a message
  lioranboardclient.onmessage = (event) => {
    boardmessage(event);
  };
}

// receiving a message from lioranboard
function boardmessage(event) {
  if (typeof (event.data) === 'string') {
    str = event.data;
    val = str.slice(0, 1);
    str = str.slice(2, str.length);
    switch (val) {
      default:
        break;
        // connect to pubsub now
      case '0':
        document.getElementById('topubsub').innerHTML = 'Connection request to PubSub.';
        serverurl = str;// not used
        on_server = 1;
        connectserver();
        connecttwitchchat();
        twitch_timeout = 4000;
        break;
        // transmitting LioranBoard message to pubsub
      case '1':
        pubsubserver.send(str);
        break;
        // send api request
      case '2':
        apiconnect(str);
        break;
        // JSON string from LioranBoard
      case '3':
        LBExtensionReceived(str);
        if (LBDebugPost) LBDebugPost('receiver', event.data);
        break;
        // reload transmitter
      case '4':
        window.location.reload();
        break;
        // send stuff to twitch chat
      case '5':
        TwitchChatConnect.send(str);
        if (LBDebugPost) LBDebugPost('chatSent', str);
        break;
    }
  } else {
    console.log('Message received from LioranBoard is not a string.');
  }
}
// call Twitch api to get user token and info
function apiconnect(api_request) {
  // get information about OAuth token
  (function getAuthToken() {
    const url = 'https://id.twitch.tv/oauth2/validate';
    const headers = {
      Authorization: `OAuth ${api_request}`,
    };
    fetchRequest(url, headers)
      .then((res) => lioranboardclient.send(`tokeninfo:${JSON.stringify(res)}`))
      .catch((e) => LBAlert(`Twitch Oauth2 Validate Error: ${e}`));
  }());
  (function getUserInfo() {
    const url = 'https://api.twitch.tv/helix/users';
    const headers = {
      Authorization: `Bearer ${api_request}`,
      'Client-ID': TWITCH_CLIENT_ID,
    };
    fetchRequest(url, headers, null, 'PUT')
      .then((res) => lioranboardclient.send(`userinfo:${JSON.stringify(res)}`))
      .catch((e) => LBAlert(`Twitch Getting User Info Error: ${e}`));
  }());
}

/// PubSub connection
// connect to Twitch pubsub
function connectserver() {
  pubsubserver = (new WebSocket('wss://pubsub-edge.twitch.tv'));
  // attempt to reconnect on disconnect, unless LioranBoard is disconnected
  pubsubserver.onclose = function (event) {
    if (on_server == 1) {
      connectserver();
      ConnectionStatus('topubsub', 'disconnected', 'Connection closed. Attempting to reconnect.', 'red');
      const i_obj = {
        topic: 'pubsubdisconnected',
        type: 'MESSAGE',
      };
      lioranboardclient.send(JSON.stringify(i_obj));
      // lioranboardclient.send("pubsubdisconnected");
    } else {
      ConnectionStatus('topubsub', 'disconnected', 'Connection closed.', 'red');
    }
    if (LBDebugPost) LBDebugPost('pubsub', event);
  };
  // notify lioranboard that pubsub connection is establishd successfully
  pubsubserver.onopen = function (event) {
    ConnectionStatus('topubsub', 'connected', 'Connected.', 'green');
    const i_obj = {
      topic: 'pubsubconnected',
      type: 'MESSAGE',
    };
    lioranboardclient.send(JSON.stringify(i_obj));
    console.log('Connected to PubSub');
    // lioranboardclient.send("pubsubconnected");
    if (LBDebugPost) LBDebugPost('pubsub', 'Connection Opened');
  };
  // receive data from pubsub, so send it to LioranBoard
  pubsubserver.onmessage = function (event) {
    servermessage(event);
    if (LBDebugPost) LBDebugPost ('pubsub', event.data);
  };
  pubsubserver.onerror = function (e) {
    if (LBDebugPost) LBDebugPost('pubsub', `Connection Error ${JSON.stringify(e)}`);
  };
}

// receive message from pubsub
function servermessage(event) {
  // console.log("Pubsub message received.")
  if (typeof (event.data) === 'string') {
    // console.log(event.data)
    lioranboardclient.send(event.data);
  } else {
    // console.log("Message received from PubSub is not a string")
  }
}
/// PubSub connection end
function twitchchatping() {
  TwitchChatConnect.send('PONG :tmi.twitch.tv');
}
function clear_raiders() {
  just_raided.shift();
}
// twitch chat connection
function connecttwitchchat() {
  if (on_server == 0) { return 0; }
  TwitchChatConnect = (new WebSocket('wss://irc-ws.chat.twitch.tv:443'));
  TwitchChatConnect.binaryType = 'arraybuffer';
  TwitchChatConnect.onopen = function (event) {
    ConnectionStatus('tochat', 'connected', 'Connected.', 'green');
    console.log('Connected to twitch chat');
    const i_obj = {
      topic: 'twitchchatconnected',
      type: 'MESSAGE',
    };
    lioranboardclient.send(JSON.stringify(i_obj));
    twitchpingid = setInterval(twitchchatping, 120000);
    twitch_timeout = 4000;
    if (LBDebugPost) LBDebugPost('chatReceive', 'Connection Opened');
  };
  TwitchChatConnect.onmessage = function (event) {
    if (LBDebugPost) LBDebugPost('chatReceive', event.data);
    let i_data; let i_type; let i_real_name; let i_channel; let user_id;
    let { data } = event;
    const i_count = (data.match(/\r\n/g) || []).length;
    for (let i = 0; i < i_count; i++) {
      let i_pos = data.indexOf('\r\n');
      let i_str = ` ${data.slice(0, i_pos)}`;
      data = data.slice(i_pos + 2);
      // ping back
      if (i_str.includes('PING')) {
        TwitchChatConnect.send('PONG :tmi.twitch.tv');
      } else {
        // seperate data
        i_pos = i_str.indexOf(' :') + 1;
        i_data = i_str.slice(0, i_pos);
        i_str = i_str.slice(i_pos + 1);

        // get type of data
        i_pos = i_str.indexOf(':');
        i_type = i_str.slice(0, i_pos);
        i_str = i_str.slice(i_pos + 1);
        i_real_name = i_type;
        i_pos = i_type.indexOf(' ');
        i_type = i_type.slice(i_pos + 1);
        i_pos = i_type.indexOf(' ');

        if (i_pos !== -1) {
          i_channel = i_type.slice(i_type.indexOf(' ') + 1);
          i_channel = i_channel.replace(' ', '');
          i_channel = i_channel.replace('#', '');
          i_type = i_type.slice(0, i_pos);
        }
        switch (i_type) {
          default:
            break;
          // connected
          case '001': {
            const i_obj = {
              topic: 'ChatConnected',
              type: 'MESSAGE',
            };
            lioranboardclient.send(JSON.stringify(i_obj));
          } break;
            // disconnected
          case 'USERNOTICE':
            i_type = IRCdataparse(i_data, 'msg-id');
            // raid
            if (i_type == 'raid') {
              let i_amount = IRCdataparse(i_data, 'viewerCount');
              if (i_amount == '') { i_amount = '1'; }
              const i_name = IRCdataparse(i_data, 'msg-param-displayName');
              // get user id
              user_id = IRCdataparse(i_data, 'user-id');
              i_real_name = IRCdataparse(i_data, 'login');
              // make sure the raider didn't just raid
              if (just_raided.some((item) => item === i_name) == false) {
                just_raided.push(i_name);
                setTimeout(clear_raiders, 5000);
                // send raid to the receiver
                const i_obj = {
                  topic: 'raidmessage',
                  type: 'MESSAGE',
                  login: i_real_name,
                  name: i_name,
                  user_id,
                  amount: i_amount,
                };
                lioranboardclient.send(JSON.stringify(i_obj));
              }
            }
            // subgift
            else if (i_type == 'submysterygift') {
              let i_amount = IRCdataparse(i_data, 'msg-param-mass-gift-count');
              if (i_amount == '') { i_amount = '1'; }
              let i_name = IRCdataparse(i_data, 'display-name');
              i_real_name = IRCdataparse(i_data, 'login');
              const i_userid = IRCdataparse(i_data, 'user-id');
              let i_plan = IRCdataparse(i_data, 'msg-param-sub-plan');
              if (i_plan == '2000') {
                i_plan = 'Tier 2';
              } else if (i_plan == '3000') {
                i_plan = 'Tier 3';
              } else {
                i_plan = 'Tier 1';
              }
              if ((i_userid == '') || (i_userid == '274598607')) {
                i_real_name = 'Anonymous User';
                i_name = 'Anonymous User';
              }
              // send gift sub to the receiver
              const i_obj = {
                topic: 'giftsubmessage',
                type: 'MESSAGE',
                login: i_real_name,
                name: i_name,
                user_id: i_userid,
                amount: i_amount,
                plan: i_plan,
              };
              lioranboardclient.send(JSON.stringify(i_obj));
            }
            break;
          case 'PRIVMSG': {
            // get display name
            let i_name = IRCdataparse(i_data, 'display-name');
            // get user id
            user_id = IRCdataparse(i_data, 'user-id');
            // get Emote
            const i_emote = IRCdataparse(i_data, 'emotes');
            // get color
            const i_color = IRCdataparse(i_data, 'color');
            // get user name
            i_pos = i_real_name.indexOf('!');
            i_real_name = i_real_name.slice(0, i_pos);

            // badges
            const i_badge = IRCdataparse(i_data, 'badges');
            if (i_real_name == 'jtv') {
              i_pos = i_str.indexOf('hosting');
              i_name = i_str.slice(0, i_str.indexOf(' '));
              if (just_raided.some((item) => item === i_name) == false) {
                setTimeout(clear_raiders, 5000);
                just_raided.push(i_name);
                let i_amount = i_str.slice(i_pos);
                i_amount = i_amount.replace(/\D/g, '');
                if (i_amount == '') { i_amount = '0'; }
                // send host to the receiver
                const i_obj = {
                  topic: 'hostmessage',
                  type: 'MESSAGE',
                  name: i_name,
                  amount: i_amount,
                };
                lioranboardclient.send(JSON.stringify(i_obj));
              }
            } else {
              const i_obj = {
                emotes: i_emote,
                login: i_real_name,
                display_name: i_name,
                user_id,
                color: i_color,
                badge: i_badge,
                message: i_str,
                channel: i_channel,
                topic: 'chatmessage',
                type: 'MESSAGE',
              };
              lioranboardclient.send(JSON.stringify(i_obj));
            }
          } break;

          case 'WHISPER': {
            // get display name
            const i_name = IRCdataparse(i_data, 'display-name');
            // get color
            const i_color = IRCdataparse(i_data, 'color');
            // get Emote
            const i_emote = IRCdataparse(i_data, 'emotes');
            // badges
            const i_badge = IRCdataparse(i_data, 'badges');
            // get user id
            user_id = IRCdataparse(i_data, 'user-id');
            // get user name
            i_pos = i_real_name.indexOf('!');
            i_real_name = i_real_name.slice(0, i_pos);

            const i_obj = {
              emotes: i_emote,
              login: i_real_name,
              display_name: i_name,
              user_id,
              color: i_color,
              badge: i_badge,
              message: i_str,
              channel: 'w',
              topic: 'chatmessage',
              type: 'MESSAGE',
            };
            lioranboardclient.send(JSON.stringify(i_obj));
          } break;
        }
      }
    }
  };
  TwitchChatConnect.onclose = () => {
    if (on_server == 1) {
      ConnectionStatus('tochat', 'disconnected', `Disconnected. Attempting to reconnect in ${twitch_timeout / 1000} s.`, 'red');
      console.log(`Disconnected from twitch chat. Attempting to reconnect in ${twitch_timeout / 1000} seconds.`);
      twitchreconnecting = setTimeout(connecttwitchchat, twitch_timeout);
      twitch_timeout *= 2;
      if (twitch_timeout >= 300000) { twitch_timeout = 300000; }
    } else {
      ConnectionStatus('tochat', 'disconnected', 'Disconnected.', 'red');
      console.log('Disconnected from twitch chat.');
    }
    clearInterval(twitchpingid);
    if (LBDebugPost) LBDebugPost('chatReceive', 'Connection Closed');
  };

  TwitchChatConnect.onerror = (e) => {
    if (LBDebugPost) LBDebugPost('chatReceive', `Connection Error ${JSON.stringify(e)}`);
  };
}

// parse through irc messages
function IRCdataparse(str, parse) {
  let i_pos;
  i_pos = str.indexOf(`${parse}=`);
  if (i_pos == -1) {
    return '';
  }
  str = str.slice(i_pos + 1 + parse.length);
  i_pos = str.indexOf(';');
  if (i_pos != -1) {
    str = str.slice(0, i_pos);
  }
  return str;
}

/// LB helper functions
const requestKeys = new Map();
const requestKeyLength = 32;
const requestTimeout = 2000;
function createKey() {
  let unique = 0;
  let key;
  do {
    key = '';
    for (let i = 0; i < requestKeyLength; i++) {
      key += Math.floor(Math.random() * 10);
    }
    if (!requestKeys.has(key)) {
      requestKeys.set(key, 1);
      unique = 1;
    }
  }
  while (unique === 0);
  return key;
}
function removeKey(key) {
  requestKeys.delete(key);
}
/**
* Get a variable or stack from LB without hook
* @param {string} name - name of the variable or stack
* @param {string} type - 'variable' (not defined) or stack
*/
function LBGetNoHook(name, type) {
  return new Promise((resolve, reject) => {
    const key = createKey();
    let timer;
    function listener() {
      if (typeof (event.data) !== 'string' || event.data.slice(0, 1) !== '3') return;
      msgJSON = event.data.slice(2, event.data.length);
      const dataObj = JSON.parse(msgJSON);
      if (dataObj.datatype !== key) return;
      clearTimeout(timer);
      lioranboardclient.removeEventListener('message', listener);
      resolve(dataObj);
    }
    lioranboardclient.addEventListener('message', listener);
    if (type === 'stack') {
      lioranboardclient.send(`{"type":"MESSAGE","topic":"GetStack","name":"${name}","datatype":"${key}"}`);
    } else {
      lioranboardclient.send(`{"type":"MESSAGE","topic":"GetVariable","variable":"${name}","datatype":"${key}"}`);
    }
    timer = setTimeout(() => {
      lioranboardclient.removeEventListener('message', listener);
      reject(new Error('timeout waiting for response'));
    }, requestTimeout);
  });
}

// construct extension command object
function LBConstructExtCommand(name) {
  this.type = 'MESSAGE';
  this.topic = 'ExtensionCommand';
  this.name = name;
  this.boxcount = 0;
  this.addBox = (boxname, type) => {
    const p = this.boxcount + 1;
    this[`boxname${p}`] = boxname;
    this[`boxtype${p}`] = type;
    this.boxcount += 1;
  };
}

/**
* send extension command to LB
* @param {string} name - name of the extension command
* @param {Object.<string, ('string'|'real'|'boolean')>} boxes
*   Key = box name, value = box type (string, real, boolean)
*/
function LBSendExtCommand(name, boxes) {
  const ext = new LBConstructExtCommand(name);
  for (const [key, value] of Object.entries(boxes)) {
    ext.addBox(key, value);
  }
  lioranboardclient.send(JSON.stringify(ext));
}

/**
* basic function for fetch requests
* @param {string} url - url for the fetch request.
* @param {Object} headers - headers object.
* @param {Object} body - body object.
* @param {string} method - method (default=GET)
*/
async function fetchRequest(url, headers, body, method = 'GET') {
  const params = {};
  params.method = method;
  params.headers = headers;
  if (body) params.body = JSON.stringify(body);
  const response = await fetch(url, params);
  let content;
  const text = await response.text();
  try {
    content = JSON.parse(text);
  } catch (e) { content = text; }
  if (!response.ok) {
    const error = (content.error) ? content.error.message || 'Something went wrong.' : 'Something went wrong.';
    throw error;
  }
  return content;
}

/**
* Send a yellow notification message to LB
* @param {string} msg - message to send
*/
function LBAlert(msg) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"AlertMessage","message":"${msg}"}`);
}

/**
* Send a popup message to LB
* @param {string} msg - message to send
*/
function LBPopUp(msg) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"PopupMessage","message":"${msg}"}`);
}

/**
* Set a value in LB
* @param {string} name - name of the variable
* @param {(string|number)} value - new value of the variable
* @param {boolean} real - whether the value is real (default = not real)
*/
function LBSetValue(name, value, real = false) {
  if (!real) value = `"${value}"`;
  lioranboardclient.send(`{"type":"MESSAGE","topic":"SetValue","valuename":"${name}","value":${value},"real":${real}}`);
}

/**
* Get a variable from LB (you can retrieve it via its hook)
* @param {string} name - name of the variable
* @param {string} hook - name of the hook to receive the data
*/
function LBGetValue(name, hook) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"GetVariable","variable":"${name}","datatype":"${hook}"}`);
}

/**
* Send an extension trigger to LB (max 20 values)
* @param {string} trigger - name of the extension trigger
* @param {(string|real)} values - values for math trigger pull command
*/
function LBTriggerExt(trigger, ...values) {
  const obj = { type: 'MESSAGE', topic: 'ExtensionTrigger', trigger };
  for (let i = 0; i < values.length; i += 1) {
    obj[`value${i + 1}`] = `${values[i]}`;
  }
  lioranboardclient.send(JSON.stringify(obj));
}

/**
* Trigger a button in LB
* @param {string} id - button ID
* @param {boolean} queuable - whether the button should be queuable (default=false)
*/
function LBTriggerBtn(id, queuable = false) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"ButtonTrigger","buttonid":"${id}","queuable":${queuable}}`);
}

/**
* Modify a button in LB
* @param {string} id - button ID
* @param {string} text - button text
* @param {number} red - red RGB value
* @param {number} green - green RGB value
* @param {number} blue - blue RGB value
* @param {string} picture - picture url
* @param {number} border - border size
*/
function LBModifyBtn(id, text = 'notext', red = -1, green = -1, blue = -1, picture = '', border = -1) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"ModifyButton","buttonid":"${id}","text":"${text}", "red":${red}, "green":${green}, "blue":${blue}, "picture":"${picture}", "border":${border}}`);
}

/**
* Get a whole stack from LB (you can retrieve it via its hook)
* @param {string} name - name of the stack
* @param {string} hook - name of the hook
*/
function LBStackGet(name, hook) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"GetStack","name":"${name}","datatype":"${hook}"}`);
}

/**
* Add a value to stack in LB
* @param {string} name - name of the stack
* @param {(string|number)} position - position to add the value to
* @param {(string|number)} value - value to add
*/
function LBStackAdd(name, position, value) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"AddStack","name":"${name}","position":"${position}", "value":"${value}"}`);
}

/**
* Replace a value in stack in LB
* @param {string} name - name of the stack
* @param {(string|number)} position - position to replace the value
* @param {(string|number)} value - value to replace
*/
function LBStackReplace(name, position, value) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"ReplaceStack","name":"${name}","position":${position}, "value":"${value}"}`);
}

/**
* Append a whole array to stack in LB
* @param {string} name - name of the stack
* @param {array} array - array to append
*/
function LBStackAppend(name, array) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"AppendStack","name":"${name}","values":${JSON.stringify(array)}}`);
}

/**
* Remove a value from stack in LB
* @param {string} name - name of the stack
* @param {(string|number)} position - position to remove the value from
*/
function LBStackRemove(name, position) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"RemoveStack","name":"${name}","position":"${position}"}`);
}

/**
* Delete a whole stack in LB
* @param {string} name - name of the stack to delete
*/
function LBStackDelete(name) {
  lioranboardclient.send(`{"type":"MESSAGE","topic":"DeleteStack","name":"${name}"}`);
}

/// LB helper functions end


  /*
  START EXTENSION STUFF HERE
  Extension are a way to connect LioranBoard to other apps and services. 
  You can build your extension in any language you want and have it connect through this Transmitter using websockets (Receiver supports only one connection).
  To Send a message to LioranBoard, simply use the function lioranboardclient.send(JSONstring);
  Find more info on all messages you can send to LioranBoard in lioranboard/extension/How to make extensions.txt file.
  */
  
  // You can receive message from lioranboard using the command "Send to Extension". The data you send is a JSON string. The String will be converted to a JSON object called LioranBoardJSON. 
  // In the JSON you can include any data you want if you use manual extension.
  // for any other extension, the datatype will be what's in the extension box.

function LBExtensionReceived(str) {
  let LioranBoardJSON;
  try {
    LioranBoardJSON = JSON.parse(str);
  } catch(e) {
    return console.log(e);
  }
  switch (LioranBoardJSON.datatype) {
    // datatype you specified.
    default:
      if (requestKeys.has(LioranBoardJSON.datatype)) {
        removeKey(LioranBoardJSON.datatype);
      } else {
        console.log(LioranBoardJSON, `Warning: Hook is missing. Extension ${LioranBoardJSON.datatype} seems to not be correctly installed.`);
      };
      break;
//[Get Version hook]
case 'LBVersionHook':
    if (typeof window.LBVersion === 'undefined') window.LBVersion = {};
    window.LBVersion[LioranBoardJSON.variable] = LioranBoardJSON.value;
    if (Object.values(window.LBVersion).length === 3) LBProcessVersion(window.LBVersion);
    break;
//[Get Version hook end]
//[Message Logging hook]
//[Message Logging hook end]
//[Change Stream hook]
case 'ChangeStream':
    LBChangeStream(LioranBoardJSON.oauth_token, LioranBoardJSON.channel_id, LioranBoardJSON.title, LioranBoardJSON.game);
    break;
//[Change Stream hook end]
//[Viewer Count hook]
case 'GetViewerCount':
    LBGetViewCount(LioranBoardJSON.channel_id, LioranBoardJSON.value_name);
    break;
//[Viewer Count hook end]
//[Subscriber Count hook]
case 'GetSubscriberCount':
    LBGetSubCount(LioranBoardJSON.oauth_token, LioranBoardJSON.channel_id, LioranBoardJSON.value_name);
    break;
//[Subscriber Count hook end]
//[Get Channel ID hook]
case 'GetChannelId':
    GetChannelId(LioranBoardJSON.oauth_token, LioranBoardJSON.name, LioranBoardJSON.Variable);
    break;
//[Get Channel ID hook end]
//[Follower Alert hook]
case 'FollowerAlert':
    LBAlert('Listening for Followers.')
    // cancel previous interval incase it is set again
    CheckFollowerFirst = 0;
    CheckFollowerList = new Array();
    if (typeof CheckFollowerTimer !== 'undefined') { clearInterval(CheckFollowerTimer); }
    CheckFollowerId = LioranBoardJSON.channel_id;
    LBCheckFollowers();
    // set a repeat so this happens every 10 second so you can compare old list and new list
    CheckFollowerTimer = setInterval(LBCheckFollowers, 10000);
    break;
//[Follower Alert hook end]
//[Bits Leaderboard hook]
case 'CheckLeaderboard':
    LBCheckBitsLeaderboard(LioranBoardJSON.oauth_token);
    break;
//[Bits Leaderboard hook end]
//[Get Profile Picture hook]
case 'GetProfilePicture':
    GetProfilePicture(LioranBoardJSON.oauth_token, LioranBoardJSON.user_name, LioranBoardJSON.value_name);
    break;
//[Get Profile Picture hook end]
//You hooks will be inserted here
/*INSERT PART 3*/
   }
}

//[Get Version script]
function LBGetVersion() {
  LBGetValue('obs_websocket_version', 'LBVersionHook');
  LBGetValue('obs_studio_version', 'LBVersionHook');
  LBGetValue('lioranboard_version', 'LBVersionHook');
}

async function LBProcessVersion(obj) {
  let receiver = obj.lioranboard_version;
  const obs = obj.obs_studio_version;
  const obsws = obj.obs_websocket_version;
  let version = JSON.parse(localStorage.getItem('LBversion'));
  const versionDate = localStorage.getItem('LBversionDate');
  if (receiver == 0) receiver = '';
  if (!version || (Date.now() - versionDate > 86000000)) await fetchVersion();
  else compareVersion(version);

  // fetch the latest version from a database
  async function fetchVersion() {
    await fetch('https://6py9buvgh1.execute-api.us-west-2.amazonaws.com/main/device/version')
      .then((response) => response.json())
      .then((data) => {
        version = {};
        data.Items.forEach((element) => {
          version[element.id.S] = element.version.S;
        });
        compareVersion(version);
        localStorage.setItem('LBversion', JSON.stringify(version));
        localStorage.setItem('LBversionDate', Date.now());
      })
      .catch((e) => console.log(e));
  }

  // compare current and latest versions
  function compareVersion(v) {
    const versionOK = '<span class="connected">OK</span>';
    const versionNA = '<span style="color:#E4B314">N/A</span';
    const tsl = document.firstChild.nextSibling.nodeValue.replace(/[^\d.-]/g, '');
    const statusOBS = (num(v.obs) > num(obs)) ? '<a href="https://obsproject.com/download" target="_blank">Update</a>' : versionOK;
    const statusOBSWS = (num(v.obsws) > num(obsws)) ? '<a href="https://github.com/Palakis/obs-websocket/releases" target="_blank">Update</a>' : versionOK;
    const statusReceiver = (num(v.receiver) > num(receiver)) ? '<a href="http://lioran.servehttp.com/share/lioranboard/download.html" target="_blank">Update</a>' : versionOK;
    const statusTSL = (num(v.transmitter) > num(tsl)) ? '<a href="http://lioran.servehttp.com/share/lioranboard/download.html" target="_blank">Update</a>' : versionOK;

    // create object of all versions
    const versionObj = {
      obs_latestV: v.obs || 'N/A', obsws_latestV: v.obsws || 'N/A', receiver_latestV: v.receiver || 'N/A', streamdeck_latestV: v.streamdeck || 'N/A', transmitter_latestV: v.transmitter || 'N/A', obs_currentV: obs || 'N/A', obsws_currentV: obsws || 'N/A', receiver_currentV: receiver || 'N/A', streamdeck_currentV: 'N/A', transmitter_currentV: tsl || 'N/A', obs_status: (obs && v.obs) ? statusOBS : versionNA, obsws_status: (obsws && v.obsws) ? statusOBSWS : versionNA, receiver_status: (receiver && v.receiver) ? statusReceiver : versionNA, streamdeck_status: versionNA, transmitter_status: (tsl && v.transmitter) ? statusTSL : versionNA,
    };

    fillValues(versionObj);

    // fill version values into table
    function fillValues(verObj) {
      Object.keys(verObj).forEach((key) => {
        document.getElementById(key).innerHTML = verObj[key];
      });
    }
  }

  // convert letters to numbers in versions to easily compare them
  function num(str) {
    if (str.search(/[a-zA-Z]/) != -1) {
      const alphabet = 'abcdefghijklmnopqrstuvwxyz';
      let letter = str.slice(str.search(/[a-zA-Z]/));
      str = str.slice(0, str.search(/[a-zA-Z]/));
      letter = letter.replace(letter, alphabet.indexOf(letter) + 1);
      str += letter;
    } else { str += 0; }
    str = str.replace(/\./g, '');
    return str;
  }
}
//[Get Version script end]
//[Message Logging script]
LBdebug = JSON.parse(localStorage.getItem('LBdebug')) || {};
dbgReceiver.checked = LBdebug.receiver;
dbgPubsub.checked = LBdebug.pubsub;
dbgChat.checked = LBdebug.chat;
LBDebugLog(dbgReceiver); LBDebugLog(dbgChat); LBDebugLog(dbgPubsub);

function LBDebugLog(e) {
  const receiver = document.getElementById('LBreceiverlog');
  const chat = document.getElementById('LBchatlog');
  const pubsub = document.getElementById('LBpubsublog');
  const listening = '<samp>Listening for traffic.</samp>';
  const disabled = '<samp>Logging is disabled.</samp>';
  // disable or enable debug logging and display it
  switch (e.id) {
    default:
      break;
    case 'dbgReceiver':
      receiver.innerHTML = (e.checked) ? '<samp>Listening for traffic in 3s.</samp>' : disabled;
      if (e.checked) setTimeout(DebugSentPacketsLB, 3000);
      LBdebug.receiver = !!(e.checked);
      break;
    case 'dbgChat':
      chat.innerHTML = (e.checked) ? listening : disabled;
      LBdebug.chat = !!(e.checked);
      break;
    case 'dbgPubsub':
      pubsub.innerHTML = (e.checked) ? listening : disabled;
      LBdebug.pubsub = !!(e.checked);
      break;
  }
  localStorage.setItem('LBdebug', JSON.stringify(LBdebug));
}

function DebugSentPacketsLB() {
  if (typeof lioranboardclient === 'undefined') return;
  lioranboardclient.__proto__._send = lioranboardclient.__proto__.send;
  lioranboardclient.__proto__.send = function (data) {
    this._send(data);
    this.send = function (data) {
      this._send(data);
      LBDebugPost('receiverSent', data);
    };
  };
}

function LBDebugPost(type, msg) {
  const receiverlog = document.getElementById('LBreceiverlog');
  const pubsublog = document.getElementById('LBpubsublog');
  const chatlog = document.getElementById('LBchatlog');
  const arrowDown = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="red" class="bi bi-arrow-down" viewBox="0 0 16 16"> <path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/> </svg>';
  const arrowUp = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="green" class="bi bi-arrow-up" viewBox="0 0 16 16"> <path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/> </svg>';

  // post a message into the debug log if enabled
  switch (type) {
    default:
      break;
    case 'receiver':
      if (LBdebug && LBdebug.receiver) {
        receiverlog.innerHTML = `${receiverlog.innerHTML} <br> ${arrowDown} <samp>${StringifyandReplace(msg)}</samp>`;
      }
      break;
    case 'receiverSent':
      if (LBdebug && LBdebug.receiver && !((msg).includes('PONG') || (msg).includes('PING'))) {
        receiverlog.innerHTML = `${receiverlog.innerHTML} <br> ${arrowUp} <samp>${StringifyandReplace(msg)}</samp>`;
      }
      break;
    case 'pubsub':
      if (LBdebug && LBdebug.pubsub && !(msg).includes('PONG')) {
        pubsublog.innerHTML = `${pubsublog.innerHTML} <br> ${arrowDown} <samp>${StringifyandReplace(msg)} </samp>`;
      }
      break;
    case 'chatReceive':
      if (LBdebug && LBdebug.chat && !JSON.stringify(msg).includes('PING')) {
        chatlog.innerHTML = `${chatlog.innerHTML} <br> ${arrowDown} <samp>${StringifyandReplace(msg)} </samp>`;
      }
      break;
    case 'chatSent':
      if (LBdebug && LBdebug.chat && !msg.includes('PONG')) {
        chatlog.innerHTML = `${chatlog.innerHTML} <br> ${arrowUp} <samp>${StringifyandReplace(msg)}</samp>`;
      }
      break;
  }

  // stringify if message is an object and replace some symbols
  // for better readability
  function StringifyandReplace(obj) {
    if (typeof obj === 'object') obj = JSON.stringify(obj);
    const strRpl = obj.replace(/\r\n/g, '').replace(/\\/g, '').replace(/\\/g, '');
    return strRpl;
  }
}
//[Message Logging script end]
//[Change Stream script]
function LBChangeStream(oauthtoken, channel_id, title, game) {
  const change_stream = {};
  change_stream.channel = {};
  // add title change if not empty string
  if (title !== '') {
    change_stream.channel.status = title;
  }
  // add game change if not empty string
  if (game !== '') {
    change_stream.channel.game = game;
  }
  // send request to twitch
  const url = `https://api.twitch.tv/kraken/channels/${channel_id}`;
  const headers = {
    Accept: 'application/vnd.twitchtv.v5+json',
    'Content-Type': 'application/json',
    Authorization: `OAuth ${oauthtoken}`,
    'Client-ID': TWITCH_CLIENT_ID,
  };
  fetchRequest(url, headers, change_stream, 'PUT')
    .then(() => LBAlert('Stream Status successfully changed'))
    .catch((e) => LBAlert(`Stream Status Error: ${e}`));
}
//[Change Stream script end]
//[Viewer Count script]
function LBGetViewCount(channelid, valuename) {
  const url = `https://api.twitch.tv/kraken/streams/${channelid}`;
  const method = 'GET';
  const headers = {
    Accept: 'application/vnd.twitchtv.v5+json',
    'Client-ID': TWITCH_CLIENT_ID,
  };
  fetchRequest(url, headers, null, method)
    .then((res) => {
      let count = -1;
      if (res.stream != null) count = res.stream.viewers;
      LBSetValue(valuename, count, true);
    })
    .catch((e) => LBAlert(`Viewer Count Error: ${e}`));
}
//[Viewer Count script end]
//[Subscriber Count script]
function LBGetSubCount(oauthtoken, channelid, valuename) {
  const url = `https://api.twitch.tv/kraken/channels/${channelid}/subscriptions?limit=5`;
  const headers = {
    Accept: 'application/vnd.twitchtv.v5+json',
    Authorization: `OAuth ${oauthtoken}`,
    'Client-ID': TWITCH_CLIENT_ID,
  };
  fetchRequest(url, headers)
    .then((res) => LBSetValue(valuename, res._total - 1, true))
    .catch((e) => LBAlert(`Get Sub Count Error: ${e}`));
}
//[Subscriber Count script end]
//[Get Channel ID script]
function GetChannelId(oauthtoken, loginname, variable) {
  const url = `https://api.twitch.tv/helix/users?login=${loginname}`;
  const headers = {
    Authorization: `Bearer ${oauthtoken}`,
    'Client-ID': TWITCH_CLIENT_ID,
  };
  fetchRequest(url, headers)
    .then((res) => lioranboardclient.send(`{"type":"MESSAGE","topic":"SetVariable","variable":"${variable}","value":"${res.data[0].id}"}`))
    .catch((e) => LBAlert(`Get Channel ID Error: ${e}`));
}
//[Get Channel ID script end]
//[Follower Alert script]
function LBCheckFollowers() {
  const url = `https://api.twitch.tv/kraken/channels/${CheckFollowerId}/follows?limit=${30 - CheckFollowerFirst * 15}`;
  const headers = {
    Accept: 'application/vnd.twitchtv.v5+json',
    'Client-ID': TWITCH_CLIENT_ID,
  };
  fetchRequest(url, headers)
    .then((res) => followListener(res))
    .catch((e) => LBAlert(`LB Follower Alert Error: ${e}`));

  // listen for receiving follower list
  function followListener(followerJSON) {
    if (followerJSON._total == 0) {
      LBAlert('Something went wrong with Follower Listener.');
      return 0;
    }
    let i_cd = followerJSON._total;
    if (i_cd > (30 - CheckFollowerFirst * 15)) { i_cd = (30 - CheckFollowerFirst * 15); }
    if (CheckFollowerFirst == 0) {
      for (var ii = 0; ii < i_cd; ii++) {
        CheckFollowerList.push(followerJSON.follows[ii].user.name);
      }
    }

    // go through the list and compare to old one see if there is any new names in the new one
    i_cd--;
    if (typeof oldfollowerJSON !== 'undefined') {
      for (var ii = i_cd; ii >= 0; ii--) {
        if (oldfollowerJSON.follows.some((item) => item.user.name === followerJSON.follows[ii].user.name) == false) {
          if (CheckFollowerList.some((item) => item === followerJSON.follows[ii].user.name) == false) {
            CheckFollowerList.push(followerJSON.follows[ii].user.name);
            // send to lioran board as "Follower Alert" with value1 being the name of the follower. pull 1 is their name  pull 2 is channel id of the personne
            LBTriggerExt('Follower Alert', followerJSON.follows[ii].user.name, followerJSON.follows[ii].user._id, followerJSON.follows[ii].user.display_name);
          }
        }
      }
    }
    CheckFollowerFirst = 1;
    oldfollowerJSON = followerJSON;
    followerJSON = null;
    return 1;
  }
}
function fakefollow() {
  const i_name = fakename();
  LBTriggerExt('Follower Alert', i_name.toLowerCase(), '123456789', i_name);
}
//[Follower Alert script end]
//[Bits Leaderboard script]
function LBCheckBitsLeaderboard(oauthtoken) {
  const url = 'https://api.twitch.tv/helix/bits/leaderboard?count=3';
  const headers = {
    Authorization: `Bearer ${oauthtoken}`,
    'Client-ID': TWITCH_CLIENT_ID,
  };

  fetchRequest(url, headers)
    .then((res) => BitsLeaderboardListener(res))
    .catch((e) => LBAlert(`Bits Leaderboard Error: ${e}`));
  // listening for twitch reply
  function BitsLeaderboardListener(BitsLeaderboardJSON) {
    // set values for all the relevant info
    LBSetValue('no1_bits', BitsLeaderboardJSON.data[0].user_name, false);
    LBSetValue('no1_bits_score', BitsLeaderboardJSON.data[0].score, true);
    LBSetValue('no2_bits', BitsLeaderboardJSON.data[1].user_name, false);
    LBSetValue('no2_bits_score', BitsLeaderboardJSON.data[1].score, true);
    LBSetValue('no3_bits', BitsLeaderboardJSON.data[2].user_name, false);
    LBSetValue('no3_bits_score', BitsLeaderboardJSON.data[2].score, true);
    // send an extension trigger "Bits Leaderboard"
    LBTriggerExt('Bits Leaderboard', '');
  }
}
//[Bits Leaderboard script end]
//[Get Profile Picture script]
function GetProfilePicture(oauthtoken, user_name, value_name) {
  const url = `https://api.twitch.tv/kraken/users?login=${user_name}`;
  const headers = {
    'Content-Type': 'application/json',
    Authorization: `Bearer ${oauthtoken}`,
    'Client-ID': TWITCH_CLIENT_ID,
    Accept: 'application/vnd.twitchtv.v5+json',
  };
  fetchRequest(url, headers)
    .then((res) => LBSetValue(value_name, res.users[0].logo))
    .catch((e) => LBAlert(`Get Profile Picture Error: ${e}`));
}
//[Get Profile Picture script end]
// your main script will be inserted here
/*INSERT PART 4*/

  </script>
  <script src="https://cdn.jsdelivr.net/npm/@shopify/draggable@1.0.0-beta.11/lib/draggable.bundle.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js" integrity="sha512-qTXRIMyZIFb8iQcfjXWCO8+M5Tbc38Qi5WzdPOYZHIlZpzBHG3L3by84BBBOiRGiEb7KKtAOAs5qYdUiZiQNNQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src= "https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js" integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script> 
  <script src="https://cdn.jsdelivr.net/npm/obs-websocket-js@4.0.2/dist/obs-websocket.js"></script>
  </html>